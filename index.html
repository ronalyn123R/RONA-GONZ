<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Smart Sudoku Game</title>
<style>
body {
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  max-width: 480px;
  margin: 30px auto;
  padding: 0 15px;
  text-align: center;
  background: linear-gradient(135deg, #74ebd5 0%, #ACB6E5 100%);
  color: #222;
  user-select: none;
}

h1 {
  margin-bottom: 15px;
  color: #fff;
  text-shadow: 0 2px 4px rgba(0,0,0,0.4);
  font-weight: 700;
  letter-spacing: 2px;
}

#sudoku {
  border-radius: 12px;
  border: 4px solid #2c3e50;
  box-shadow:
    0 4px 10px rgba(0,0,0,0.25),
    inset 0 0 15px rgba(255,255,255,0.15);
  display: grid;
  grid-template-columns: repeat(9, 1fr);
  grid-template-rows: repeat(9, 1fr);
  gap: 2px;
  margin: 20px auto;
  width: 450px;
  height: 450px;
  background: #1abc9c;
}

.cell {
  position: relative;
  border: 1px solid #16a085;
  font-size: 22px;
  text-align: center;
  font-weight: 700;
  color: #05386b;
  background: #d1f2eb;
  border-radius: 6px;
  transition: background-color 0.3s ease, box-shadow 0.3s ease;
  display: flex;
  align-items: center;
  justify-content: center;
  user-select: none;
}

.cell.block-right {
  border-right: 3.5px solid #2c3e50;
}
.cell.block-bottom {
  border-bottom: 3.5px solid #2c3e50;
}

input.cell-input {
  width: 100%;
  height: 100%;
  font-size: 22px;
  text-align: center;
  border: none;
  outline: none;
  font-weight: 700;
  background-color: transparent;
  color: #05386b;
  user-select: text;
  border-radius: 6px;
  transition: background-color 0.3s ease;
  cursor: text;
}

input.cell-input:disabled {
  background-color: #95e1d3;
  color: #055a8c;
  cursor: default;
  box-shadow: inset 0 0 5px #0e4d6f;
}

input.cell-input.invalid {
  background-color: #f76c6c !important;
  color: white !important;
  box-shadow: 0 0 8px #ff3b3b;
}

input.cell-input:not(:disabled):hover,
input.cell-input:not(:disabled):focus {
  background-color: #a0e7e5;
  box-shadow: 0 0 8px #1abc9c;
  color: #0b3d91;
}

button {
  background: linear-gradient(45deg, #11998e, #38ef7d);
  border: none;
  border-radius: 25px;
  color: white;
  font-weight: 700;
  padding: 12px 30px;
  font-size: 16px;
  margin: 10px 10px 30px;
  cursor: pointer;
  box-shadow: 0 6px 15px rgba(56, 239, 125, 0.5);
  transition: background 0.3s ease, transform 0.2s ease;
}

button:hover {
  background: linear-gradient(45deg, #0f7a74, #2abf67);
  transform: scale(1.05);
}

button:active {
  transform: scale(0.98);
}

#message {
  font-weight: 700;
  font-size: 18px;
  margin-top: 10px;
  min-height: 24px;
  color: #fff;
  text-shadow: 1px 1px 3px rgba(0,0,0,0.6);
}
</style>
</head>
<body>

<h1>Smart Sudoku Game</h1>

<div id="sudoku"></div>

<button onclick="checkSolution()">Check</button>
<button onclick="resetBoard()">Reset</button>

<div id="message"></div>

<script>
const puzzle = [
  [5,3,0, 0,7,0, 0,0,0],
  [6,0,0, 1,9,5, 0,0,0],
  [0,9,8, 0,0,0, 0,6,0],
  [8,0,0, 0,6,0, 0,0,3],
  [4,0,0, 8,0,3, 0,0,1],
  [7,0,0, 0,2,0, 0,0,6],
  [0,6,0, 0,0,0, 2,8,0],
  [0,0,0, 4,1,9, 0,0,5],
  [0,0,0, 0,8,0, 0,7,9]
];

const sudokuDiv = document.getElementById('sudoku');
const size = 9;

function renderBoard() {
  sudokuDiv.innerHTML = '';
  for(let r=0; r<size; r++) {
    for(let c=0; c<size; c++) {
      const cell = document.createElement('div');
      cell.classList.add('cell');
      if ((c + 1) % 3 === 0 && c !== 8) cell.classList.add('block-right');
      if ((r + 1) % 3 === 0 && r !== 8) cell.classList.add('block-bottom');

      const input = document.createElement('input');
      input.type = 'text';
      input.maxLength = 1;
      input.classList.add('cell-input');
      input.setAttribute('data-row', r);
      input.setAttribute('data-col', c);
      input.autocomplete = "off";

      if(puzzle[r][c] !== 0) {
        input.value = puzzle[r][c];
        input.disabled = true;
      }

      input.addEventListener('input', (e) => {
        if (!/^[1-9]$/.test(e.target.value)) {
          e.target.value = '';
        }
        validateBoard();
      });

      cell.appendChild(input);
      sudokuDiv.appendChild(cell);
    }
  }
}

function validateBoard() {
  clearValidation();
  let board = Array.from({length: size}, () => Array(size).fill(0));
  document.querySelectorAll('input.cell-input').forEach(input => {
    const r = +input.getAttribute('data-row');
    const c = +input.getAttribute('data-col');
    board[r][c] = input.value ? parseInt(input.value) : 0;
  });

  for(let r=0; r<size; r++) checkDuplicates(board[r], 'row', r);
  for(let c=0; c<size; c++) {
    let colVals = [];
    for(let r=0; r<size; r++) colVals.push(board[r][c]);
    checkDuplicates(colVals, 'col', c);
  }
  for(let br=0; br<3; br++) {
    for(let bc=0; bc<3; bc++) {
      let blockVals = [];
      for(let r=br*3; r<br*3+3; r++) {
        for(let c=bc*3; c<bc*3+3; c++) {
          blockVals.push(board[r][c]);
        }
      }
      checkDuplicates(blockVals, 'block', br*3 + bc);
    }
  }
}

function checkDuplicates(arr, type, idx) {
  let counts = {};
  arr.forEach((val, i) => {
    if(val !== 0) counts[val] = (counts[val] || 0) + 1;
  });
  for(let val in counts) {
    if(counts[val] > 1) {
      arr.forEach((cellVal, i) => {
        if(cellVal == val) markInvalidCell(type, idx, i);
      });
    }
  }
}

function markInvalidCell(type, idx, pos) {
  let selector;
  if(type === 'row') selector = `input.cell-input[data-row="${idx}"][data-col="${pos}"]`;
  if(type === 'col') selector = `input.cell-input[data-row="${pos}"][data-col="${idx}"]`;
  if(type === 'block') {
    const br = Math.floor(idx / 3);
    const bc = idx % 3;
    const r = br*3 + Math.floor(pos / 3);
    const c = bc*3 + (pos % 3);
    selector = `input.cell-input[data-row="${r}"][data-col="${c}"]`;
  }
  const cell = document.querySelector(selector);
  if(cell) cell.classList.add('invalid');
}

function clearValidation() {
  document.querySelectorAll('input.cell-input.invalid').forEach(input => {
    input.classList.remove('invalid');
  });
  document.getElementById('message').textContent = '';
}

function checkSolution() {
  validateBoard();
  if(document.querySelectorAll('input.cell-input.invalid').length > 0) {
    document.getElementById('message').textContent = 'There are errors in the board. Fix highlighted cells.';
    document.getElementById('message').style.color = 'red';
    return;
  }
  for(let input of document.querySelectorAll('input.cell-input')) {
    if(input.value === '') {
      document.getElementById('message').textContent = 'The board is not complete yet.';
      document.getElementById('message').style.color = 'orange';
      return;
    }
  }
  document.getElementById('message').textContent = 'Congratulations! You solved the Sudoku!';
  document.getElementById('message').style.color = 'green';
}

function resetBoard() {
  document.querySelectorAll('input.cell-input').forEach(input => {
    if (!input.disabled) {
      input.value = '';
      input.classList.remove('invalid');
    }
  });
  document.getElementById('message').textContent = '';
}

renderBoard();
validateBoard();



function checkSolution() {
  validateBoard();
  if (document.querySelectorAll('input.cell-input.invalid').length > 0) {
    document.getElementById('message').textContent = 'There are errors in the board. Fix highlighted cells.';
    document.getElementById('message').style.color = 'red';
    return;
  }
  for (let input of document.querySelectorAll('input.cell-input')) {
    if (input.value === '') {
      document.getElementById('message').textContent = 'The board is not complete yet.';
      document.getElementById('message').style.color = 'orange';
      return;
    }
  }

  // ðŸŽ‰ Surprise message
  document.getElementById('message').textContent = 'ðŸŽ‰ Congratulations! You solved the Sudoku! ðŸŽ‰';
  document.getElementById('message').style.color = 'green';

  // Confetti effect
  startConfetti();

  // Wait a bit, then load next puzzle
  setTimeout(() => {
    stopConfetti();
    loadNextPuzzle();
  }, 4000);
}

// Example confetti effect (simple)
function startConfetti() {
  const confettiCanvas = document.createElement('canvas');
  confettiCanvas.id = 'confettiCanvas';
  confettiCanvas.style.position = 'fixed';
  confettiCanvas.style.top = 0;
  confettiCanvas.style.left = 0;
  confettiCanvas.style.pointerEvents = 'none';
  confettiCanvas.width = window.innerWidth;
  confettiCanvas.height = window.innerHeight;
  document.body.appendChild(confettiCanvas);

  const ctx = confettiCanvas.getContext('2d');
  const pieces = Array.from({ length: 150 }, () => ({
    x: Math.random() * confettiCanvas.width,
    y: Math.random() * confettiCanvas.height,
    w: 5 + Math.random() * 5,
    h: 10 + Math.random() * 10,
    color: `hsl(${Math.random() * 360}, 100%, 50%)`,
    speed: Math.random() + 1
  }));

  function draw() {
    ctx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height);
    pieces.forEach(p => {
      ctx.fillStyle = p.color;
      ctx.fillRect(p.x, p.y, p.w, p.h);
      p.y += p.speed;
      if (p.y > confettiCanvas.height) p.y = -10;
    });
    confettiCanvas._animation = requestAnimationFrame(draw);
  }
  draw();
}

function stopConfetti() {
  const canvas = document.getElementById('confettiCanvas');
  if (canvas) {
    cancelAnimationFrame(canvas._animation);
    canvas.remove();
  }
}

// Load a new puzzle (you can replace with harder one)
function loadNextPuzzle() {
  const nextPuzzle = [
    [0,0,0, 2,6,0, 7,0,1],
    [6,8,0, 0,7,0, 0,9,0],
    [1,9,0, 0,0,4, 5,0,0],
    [8,2,0, 1,0,0, 0,4,0],
    [0,0,4, 6,0,2, 9,0,0],
    [0,5,0, 0,0,3, 0,2,8],
    [0,0,9, 3,0,0, 0,7,4],
    [0,4,0, 0,5,0, 0,3,6],
    [7,0,3, 0,1,8, 0,0,0]
  ];
  for (let r = 0; r < size; r++) {
    for (let c = 0; c < size; c++) {
      puzzle[r][c] = nextPuzzle[r][c];
    }
  }
  renderBoard();
  validateBoard();
}
</script>
</body>
</html>